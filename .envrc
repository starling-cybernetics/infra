# Make sure this script is evaluated strictly
strict_env

# Watch all nix files for changes
watch_file $(find . -name "*.nix" -printf '"%p" ')

# Dot env filename for variables shared with all production environments
COMMON_DOT_ENV_FILE=common.env

# Dot env filename for secret variables shared with all production environments
SECRET_DOT_ENV_FILE=secret.env

# Watch the .env files for changes
watch_file $COMMON_DOT_ENV_FILE
watch_file $SECRET_DOT_ENV_FILE

# Only load variables from 1Password if 1Password CLI is installed and configured properly in the
# shell; otherwise, load everything from the .env file *except* for 1Password secret references.
if test -f "$SECRET_DOT_ENV_FILE"; then
  if command -v op &> /dev/null && op signin &>/dev/null; then
    # Load all the environment variables from 1Password into the current shell, as well as all the
    # normal non-secret environment variables from the .env file.
    direnv_load op run --env-file $SECRET_DOT_ENV_FILE --no-masking -- direnv dump
  else
    dotenv $SECRET_DOT_ENV_FILE
    # Remove any assignments in the .env file which were 1Password secret references, because they
    # cannot be resolved in this execution context, and it would be confusing for programs to see the
    # "op://..." syntax in a variable rather than instead report the absence of the variable.
    for assign in $(env); do
      lhs=$(echo $assign | sed -e 's/=.*$//')
      rhs=$(echo $assign | sed -e 's/^[A-Za-z_][A-Za-z0-9_]*=//')
      if echo $rhs | grep -q '^op://'; then
        unset $lhs
      fi
    done
  fi
fi

dotenv_if_exists $COMMON_DOT_ENV_FILE

use flake